# MIPS 指令集

## 指令格式说明

MIPS 指令有三种基本格式：

### R型指令格式（寄存器型）
```
| op(6) | rs(5) | rt(5) | rd(5) | shamt(5) | funct(6) |
```
- **op**: 操作码（R型指令固定为 `000000`）
- **rs**: 源寄存器1
- **rt**: 源寄存器2
- **rd**: 目标寄存器
- **shamt**: 移位量
- **funct**: 功能码（区分具体操作）

### I型指令格式（立即数型）
```
| op(6) | rs(5) | rt(5) | immediate(16) |
```
- **op**: 操作码
- **rs**: 源寄存器
- **rt**: 目标寄存器/源寄存器2
- **immediate**: 16位立即数

### J型指令格式（跳转型）
```
| op(6) | address(26) |
```
- **op**: 操作码
- **address**: 26位跳转地址

---

## R型指令 (op=`000000`)

通过 `funct` 字段区分具体操作。

| funct | 指令 | 格式 | 功能描述 |
|-------|------|------|----------|
| `100000` | **ADD** | `ADD rd, rs, rt` | rd = rs + rt |
| `100010` | **SUB** | `SUB rd, rs, rt` | rd = rs - rt |
| `100100` | **AND** | `AND rd, rs, rt` | rd = rs & rt（按位与）|
| `100101` | **OR** | `OR rd, rs, rt` | rd = rs \| rt（按位或）|
| `101010` | **SLT** | `SLT rd, rs, rt` | rd = (rs < rt) ? 1 : 0（小于则置位）|
| `000000` | **SLL** | `SLL rd, rt, shamt` | rd = rt << shamt（逻辑左移）|
| `000010` | **SRL** | `SRL rd, rt, shamt` | rd = rt >> shamt（逻辑右移）|

**格式构成**:
- **ADD/SUB/AND/OR/SLT**: `[op:6=000000][rs:5][rt:5][rd:5][shamt:5=00000][funct:6]`
- **SLL/SRL**: `[op:6=000000][rs:5=00000][rt:5][rd:5][shamt:5][funct:6]`

---

## I型指令

### 算术和逻辑指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `001000` | **ADDI** | `ADDI rt, rs, imm` | rt = rs + sign_extend(imm) |
| `001100` | **ANDI** | `ANDI rt, rs, imm` | rt = rs & zero_extend(imm) |
| `001101` | **ORI** | `ORI rt, rs, imm` | rt = rs \| zero_extend(imm) |
| `001010` | **SLTI** | `SLTI rt, rs, imm` | rt = (rs < sign_extend(imm)) ? 1 : 0 |

**格式构成**: `[op:6][rs:5][rt:5][immediate:16]`

### 访存指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `100011` | **LW** | `LW rt, imm(rs)` | rt = MEM[rs + sign_extend(imm)]（加载字）|
| `101011` | **SW** | `SW rt, imm(rs)` | MEM[rs + sign_extend(imm)] = rt（存储字）|

**格式构成**: `[op:6][rs:5][rt:5][offset:16]`

### 分支指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `000100` | **BEQ** | `BEQ rs, rt, label` | if(rs == rt) PC += sign_extend(imm<<2) |
| `000101` | **BNE** | `BNE rs, rt, label` | if(rs != rt) PC += sign_extend(imm<<2) |

**格式构成**: `[op:6][rs:5][rt:5][offset:16]`

---

## J型指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `000010` | **J** | `J label` | PC = {PC[31:28], addr, 2'b00} |
| `000011` | **JAL** | `JAL label` | $31 = PC+4; PC = {PC[31:28], addr, 2'b00} |

**格式构成**: `[op:6][address:26]`

---

## 进阶指令集（可选）

### 更多R型指令

| funct | 指令 | 格式 | 功能描述 |
|-------|------|------|----------|
| `100110` | **XOR** | `XOR rd, rs, rt` | rd = rs ^ rt（按位异或）|
| `100111` | **NOR** | `NOR rd, rs, rt` | rd = ~(rs \| rt)（按位或非）|
| `000011` | **SRA** | `SRA rd, rt, shamt` | rd = rt >>> shamt（算术右移）|

**格式构成**:
- **XOR/NOR**: `[op:6=000000][rs:5][rt:5][rd:5][shamt:5=00000][funct:6]`
- **SRA**: `[op:6=000000][rs:5=00000][rt:5][rd:5][shamt:5][funct:6]`

### 更多I型指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `001110` | **XORI** | `XORI rt, rs, imm` | rt = rs ^ zero_extend(imm) |
| `001111` | **LUI** | `LUI rt, imm` | rt = imm << 16（加载高位立即数）|

**格式构成**:
- **XORI**: `[op:6][rs:5][rt:5][immediate:16]`
- **LUI**: `[op:6][rs:5=00000][rt:5][immediate:16]`

### 字节/半字访存指令

| opcode | 指令 | 格式 | 功能描述 |
|--------|------|------|----------|
| `100000` | **LB** | `LB rt, imm(rs)` | 加载字节（符号扩展）|
| `100100` | **LBU** | `LBU rt, imm(rs)` | 加载无符号字节 |
| `100001` | **LH** | `LH rt, imm(rs)` | 加载半字（符号扩展）|
| `101000` | **SB** | `SB rt, imm(rs)` | 存储字节 |
| `101001` | **SH** | `SH rt, imm(rs)` | 存储半字 |

**格式构成**: `[op:6][rs:5][rt:5][offset:16]`

### 跳转寄存器指令（R型特殊）

| funct | 指令 | 格式 | 功能描述 |
|-------|------|------|----------|
| `001000` | **JR** | `JR rs` | PC = rs |
| `001001` | **JALR** | `JALR rd, rs` | rd = PC+4; PC = rs |

**格式构成**:
- **JR**: `[op:6=000000][rs:5][rt:5=00000][rd:5=00000][shamt:5=00000][funct:6=001000]`
- **JALR**: `[op:6=000000][rs:5][rt:5=00000][rd:5][shamt:5=00000][funct:6=001001]`

---

## 实现建议

### 阶段1: 最小指令集（5条）
基础功能，足以编写简单程序
- **ADD** - 寄存器加法
- **ADDI** - 立即数加法
- **LW** - 加载字
- **SW** - 存储字
- **BEQ** - 相等分支

### 阶段2: 扩展算术（再加5条）
增强运算能力
- **SUB** - 减法
- **AND** - 按位与
- **OR** - 按位或
- **SLT** - 小于比较
- **J** - 无条件跳转

### 阶段3: 完整基础集（再加5条）
完善逻辑和控制流
- **ANDI** - 立即数与
- **ORI** - 立即数或
- **SLTI** - 立即数比较
- **JAL** - 跳转并链接
- **BNE** - 不等分支

### 阶段4: 移位和高级（可选）
高级功能支持
- **SLL** - 逻辑左移
- **SRL** - 逻辑右移
- **SRA** - 算术右移
- **LUI** - 加载高位立即数
- **JR** - 寄存器跳转
