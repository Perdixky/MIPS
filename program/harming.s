# ==========================================
# 寄存器分配：
# $23 ($s7): 输出设备基地址 (0xFFFF0000)
# $4  ($a0): 参数 - 待校验的汉明码
# $2  ($v0): 返回值 / 临时计算
# $31 ($ra): 返回地址
# ==========================================

main:
    # --- 1. 初始化输出基地址 0xFFFF0000 ---
    # 替代 LUI: 先加载 -1，再左移 16 位
    addi $23, $0, -1        # $23 = 0xFFFFFFFF    # 0x2017FFFF
    sll  $23, $23, 16       # $23 = 0xFFFF0000    # 0x0017BC00

    # ==========================================
    # 测试案例 1: 0x0000 (全0，应该是正确的)
    # ==========================================
    add  $4, $0, $0         # $a0 = 0    # 0x00002020
    jal  run_test           # 调用校验子程序    # 0x0C000009

    # ==========================================
    # 测试案例 2: 0x0001 (第1位错误)
    # 理论结果: 错误位置=1, 纠正后=0x0000
    # ==========================================
    addi $4, $0, 1          # $a0 = 1    # 0x20040001
    jal  run_test    # 0x0C000009

    # ==========================================
    # 测试案例 3: 0x0017 (二进制 ...10111)
    # 各位分布: 1(1), 2(1), 3(1), 4(0), 5(1)...
    # 理论计算: S1=1, S2=0, S4=1, S8=0 -> Syndrome=5
    # 理论结果: 错误位置=5, 纠正后=0x0017^0x10 = 0x0007
    # ==========================================
    ori  $4, $0, 0x0017     # $a0 = 0x0017    # 0x34040017
    jal  run_test    # 0x0C000009

    # 测试结束，死循环
end_loop:
    j    end_loop    # 0x08000008


# ==========================================
# 核心逻辑: 校验并输出 (run_test)
# 输入: $4 ($a0) - 汉明码
# 功能: 计算校验位，输出结果到内存，如有错则纠正
# ==========================================
run_test:
    # 保存 $ra (既然是测试程序，不涉及多级调用，可省略栈操作，但需注意覆盖)
    # 简单起见，我们不调用其他子程序，或者把 $ra 存到临时寄存器 $20
    add  $20, $31, $0       # 备份返回地址    # 0x03E0A020

    # 1. 初始化 Syndrome ($17/$s1) = 0
    add  $17, $0, $0    # 0x00008820
    add  $16, $4, $0        # $16 = 数据副本    # 0x00808020

    # --- 计算 S1 (Mask 0x5555) ---
    ori  $8, $0, 0x5555    # 0x34085555
    and  $9, $16, $8        # 传参 $9 (Data & Mask)    # 0x02084824
    # 这里不能用 jal parity_calc，因为会覆盖 $ra
    # 我们把 parity_calc 代码内联(展开)写，或者手动跳转
    # 为了代码整洁，我们这里直接写校验逻辑：
    
    # S1 计算逻辑展开:
    add  $2, $0, $0         # sum = 0    # 0x00001020
    addi $10, $0, 16        # count = 16    # 0x200A0010
s1_loop:
    beq  $10, $0, s1_done    # 0x11400005
    andi $11, $9, 1    # 0x312B0001
    add  $2, $2, $11        # sum += bit    # 0x004B1020
    srl  $9, $9, 1    # 0x00094842
    addi $10, $10, -1    # 0x214AFFFF
    j    s1_loop    # 0x08000010
s1_done:
    andi $2, $2, 1          # sum % 2    # 0x30420001
    or   $17, $17, $2       # 合并 S1    # 0x02228825

    # --- 计算 S2 (Mask 0x6666) ---
    ori  $8, $0, 0x6666    # 0x34086666
    and  $9, $16, $8    # 0x02084824
    # S2 计算逻辑展开:
    add  $2, $0, $0    # 0x00001020
    addi $10, $0, 16    # 0x200A0010
s2_loop:
    beq  $10, $0, s2_done    # 0x11400005
    andi $11, $9, 1    # 0x312B0001
    add  $2, $2, $11    # 0x004B1020
    srl  $9, $9, 1    # 0x00094842
    addi $10, $10, -1    # 0x214AFFFF
    j    s2_loop    # 0x0800001C
s2_done:
    andi $2, $2, 1    # 0x30420001
    sll  $2, $2, 1          # S2 << 1    # 0x00021040
    or   $17, $17, $2    # 0x02228825

    # --- 计算 S4 (Mask 0x7878) ---
    ori  $8, $0, 0x7878    # 0x34087878
    and  $9, $16, $8    # 0x02084824
    # S4 计算逻辑展开:
    add  $2, $0, $0    # 0x00001020
    addi $10, $0, 16    # 0x200A0010
s4_loop:
    beq  $10, $0, s4_done    # 0x11400005
    andi $11, $9, 1    # 0x312B0001
    add  $2, $2, $11    # 0x004B1020
    srl  $9, $9, 1    # 0x00094842
    addi $10, $10, -1    # 0x214AFFFF
    j    s4_loop    # 0x08000029
s4_done:
    andi $2, $2, 1    # 0x30420001
    sll  $2, $2, 2          # S4 << 2    # 0x00021080
    or   $17, $17, $2    # 0x02228825

    # --- 计算 S8 (Mask 0x7F80) ---
    ori  $8, $0, 0x7F80    # 0x34087F80
    and  $9, $16, $8    # 0x02084824
    # S8 计算逻辑展开:
    add  $2, $0, $0    # 0x00001020
    addi $10, $0, 16    # 0x200A0010
s8_loop:
    beq  $10, $0, s8_done    # 0x11400005
    andi $11, $9, 1    # 0x312B0001
    add  $2, $2, $11    # 0x004B1020
    srl  $9, $9, 1    # 0x00094842
    addi $10, $10, -1    # 0x214AFFFF
    j    s8_loop    # 0x08000036
s8_done:
    andi $2, $2, 1    # 0x30420001
    sll  $2, $2, 3          # S8 << 3    # 0x000210C0
    or   $17, $17, $2    # 0x02228825

    # ==========================================
    # 结果处理
    # ==========================================
    beq  $17, $0, is_right  # 如果 Syndrome == 0    # 0x1220000F

    # --- 发现错误 ---
    sw   $17, 4($23)        # 输出: 错误位置索引    # 0xAEF10004

    # 构造纠错掩码 (1 << (Index-1))
    addi $10, $17, -1       # loop count    # 0x222AFFFF
    addi $11, $0, 1         # mask = 1    # 0x200B0001
    add  $12, $0, $0        # i = 0    # 0x00006020
fix_shift:
    beq  $12, $10, fix_now    # 0x118A0003
    sll  $11, $11, 1    # 0x000B5840
    addi $12, $12, 1    # 0x218C0001
    j    fix_shift    # 0x08000044
fix_now:
    # 异或纠错: (A|B) & ~(A&B)
    or   $13, $16, $11    # 0x020B6825
    and  $14, $16, $11    # 0x020B7024
    addi $15, $0, -1        # 0xFFFFFFFF    # 0x200FFFFF
    sub  $14, $15, $14      # NOT    # 0x01EE7022
    and  $16, $13, $14      # XOR Result    # 0x01AE8024

    sw   $16, 8($23)        # 输出: 纠正后的码    # 0xAEF00008
    j    test_done    # 0x08000055

is_right:
    # --- 正确 ---
    # 构造 "RGHT" (0x52474854)
    ori  $9, $0, 0x5247     # 高位    # 0x34095247
    sll  $9, $9, 16    # 0x00094C00
    ori  $10, $0, 0x4854    # 低位    # 0x340A4854
    or   $9, $9, $10    # 0x012A4825
    
    sw   $9,  4($23)        # 输出: "RGHT"    # 0xAEE90004
    sw   $16, 8($23)        # 输出: 原码    # 0xAEF00008

test_done:
    # 恢复返回地址并返回
    add  $31, $20, $0    # 0x0280F820
    jr   $31    # 0x03E00008
